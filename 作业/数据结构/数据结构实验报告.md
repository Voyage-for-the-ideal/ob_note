## PS
1. 各个实验的全部代码请见文档末的附录，报告主体仅列出部分代码。
2. 体会与心得放在最后。
##### 姓名：王玉麟
##### 学号：PB23151808
##### 课程：2024~2025秋季学期-数据结构
---
## 实验一——稀疏一元多项式计算器
> 编写一个多项式计算器，完成如下功能：1. 创建多项式节点；2. 插入节点到多项式；3. 输出多项式；4. 销毁多项式；5.清空多项式；6.求和；7.求差；8.修改（插入；删除；修改节点的系数/指数）；9.微分；10.不定积分；11. 定积分。
### 算法描述
#### 数据结构
主要使用了链表及指针结构体，即：
```c
typedef struct PolyNode {;定义多项式节点
    float coef; // 系数
    int exp;    // 指数
    struct PolyNode *next;
} PolyNode;

typedef struct {;定义链表（多项式）结构
    PolyNode *head;
    int count; // 项数
} Polynomial;
```
#### 程序结构(具体程序)
##### 创建多项式相关
1. **创建节点** `PolyNode *createNode(float coef, int exp)`
2. **插入节点** `void insertNode(Polynomial *poly, float coef, int exp)`
	按照从小到大的顺序将节点插入多项式链表中，若插入节点的指数与已存在节点相同，则进行系数运算，如果系数不为0，修改原有节点并释放插入节点的内存，如果系数为0，则直接释放该节点。
##### 输出/销毁多项式
1. **输出多项式**`void printPolynomial(Polynomial *poly)`
	遍历多项式的线性表各个节点，其中遇到正数输出“+”，遇到负数输出“-”
2. **销毁多项式**`void destroyPolynomial(Polynomial *poly)`
##### 对多项式进行操作
1. **求和**`Polynomial addPolynomial(Polynomial *poly1, Polynomial *poly2)`
	本质上是”插入多个节点到多项式中“，只需反复调用**插入节点**功能即可
2. **求差**`Polynomial subtractPolynomial(Polynomial *poly1, Polynomial *poly2)`
	只需将求和函数中每一项多项式系数修改为相反数即可。
3. **求值**`float evaluatePolynomial(Polynomial *poly, float x)`
	遍历多项式链表，按照`coef*(x^exp)`计算即可
4. **微分**`Polynomial differentiatePolynomial(Polynomial *poly)`
	遍历多项式链表，`exp=exp-1`，`coef=coef*(exp-1)`，遇到指数为0的项则直接删去该节点。
5. **不定积分与定积分**`Polynomial indefiniteIntegralPolynomial(Polynomial *poly)`
	遍历多项式链表。`exp=exp+1`，`coef=coed/(exp+1)`
##### 对项进行操作
1. **删去指定项**
	依照系数/指数查找该项，如果成功查找，释放该节点即可
2. **修改指定项**
	首先依照系数/指数查找该项，若成功查找，则先创建修改后的多项式节点，然后将原先节点在链表中删去，再将新创建的节点插入链表即可。（需满足项**从小到大排列**的规则）
3. **插入新的节点**
	与创建多项式中“插入节点”功能实现相同
### 调试分析
1. **switch...case的使用**
	如果在`switch`中再次使用`switch`以实现二级菜单的效果，则需要明确为每个`case`末尾写好`break`，并将每个分支明确用`{}`括起，否则程序无法判断break具体是跳出哪个`switch`下的`case`可能出现报错。
### 算法的时空分析
所有功能基本都是从头遍历多项式链表，故时间复杂度为$O(n)$，对相对复杂一点的操作如多项式相加，则是$O(n^2)$.
### 测试结果及分析
开始界面如下图：
![[Pasted image 20241230213014.png|400]]
向命令框输入数字，即可执行对应功能
![[Pasted image 20241230213125.png|400]]

---
## 实验二——栈与队列
### 括号配对检验
> 输入一个表达式（含有数字/字母/四则运算/括号），判断表达式中**左右大中小括号**是否匹配。
#### 算法描述
##### 数据结构
主要用了栈和数组的结构，分别用于存放待匹配的括号和输入的表达式：
```c
typedef struct {

    char *base;

    char *top;

    int stacksize;

} SqStack;
```
##### 程序结构
1. 初始化栈`void InitStack(SqStack *sqstack)`
	base/top型栈的初始化是直接给base指针分配内存。并且将top指针赋给base
2. 入/出栈`char pop(SqStack *sqstack)`，`void Push(SqStack *sqstack, char e)`
	分别在识别到左/右括号的时候触发. 
#### 调试分析
1. 由于在匹配括号时既要识别括号又要识别表达式是否已结束，故会出现多个if嵌套的情况。一定要把括号写好
2. `elemtype*`与`elemtype`的区别：前者使用->，后者使用.
3. malloc使用：malloc用于动态分配内存，故此处如果事先知道表达式最大长度，可直接用`char buffer[MAXSTACK+1]`，之后不会再对该数组做出改动。
#### 算法时空分析
遍历表达式为$O(n)$，入栈/出栈均为$O(1)$.
#### 测试结果及分析
分别测试了三个表达式，判断结果均正确。
![[Pasted image 20250115232459.png|500]]
![[Pasted image 20250115232540.png|600]]
![[Pasted image 20250115232628.png| 350]]
### 银行业务模拟
> ![[Pasted image 20241231134753.png]]
#### 算法描述
##### 数据结构
主要使用了队列，链表等结构体：
```c
typedef struct Customer{
    double time;//用户到来时间
    double wait;//用户等待时间
    int finish;//判断是否完成
    struct Customer *next;
}Customer;

typedef struct QNode{//排队
    double money;//需要的钱（有正负）
    double time;//用户到来的时间
    double wait;
    int finish;//判断操作是否完成
    struct QNode *next;
}QNode,* QueuePtr;

typedef struct{//队列
    QueuePtr front;//头
    QueuePtr rear;//尾
}LinkQueue;
```
##### 程序结构
###### 队列相关
1. **初始化队列**`void InitQueue(LinkQueue *queue)`
2. **插入队列**`void EnQueue(LinkQueue *queue,char money,char time)`
3. **弹出队首的栈**`double DeQueue(LinkQueue *queue)`
4. **检查队列**`double check_queue(LinkQueue *queue,double total,double past_total,Customer *customer,double average_time,double *real_time)`
	在第一个队列有人存钱后检查第二个队列,将可以进行操作的客户修改完成状态，增加所有未完成且已到来的客户等待时间；无法给钱的客户弹出队首再插入队尾。如此遍历直到无法给钱。
5. **最后一次检查第二队列**`void check_queue_last(LinkQueue *queue,double total,double past_total,Customer *customer,double average_time,double *real_time)`
	与`check_queue`类似，但是一旦无法取钱，直接结算等待时间（歇业时间-到达时间=最终等待时间），并将该客户出队列。
###### 链表相关
1. **链表初始化**`void Initcustomer(Customer *custmer)`
2. **插入客户进链表**`void Encustomer(Customer *customer,double time)`
3. **增加客户等待时间**`void addtime(Customer *customer,char average_time,double real_time)`
	操作时间和客户到达时间是固定的，根据到达时间唯一确定客户，“实际时间-到达时间=等待时间“
4. **将客户状态标为完成**`double finish_cust(Customer *customer,double time)`
	用以判断是否需要增加等待时间
5. **输出链表**`void print_cust(Customer *customer)`
	输出每个客户的等待时间（按照到来时间输出），最后输出等待的平均时间。
#### 调试分析
1. 队列和链表的区别：
	队列会额外定义一个头结点，由此需定义一个结构体用以存放队列的头结点和尾节点；而链表可直接定义为若干个节点。
2. 向函数传入结构体，但是函数外结构体无法改变的问题：
	只有传入这个变量的地址才可以改变变量。如果要改变一个指针，那么需要传入这个指针的地址，即，指针的指针。
	若仅传入指针本身，那么这个指针在函数内的改变不会影响主函数的内容；如果传入指针的地址，那么函数所生成的指针地址指向的内容就是主函数中的指针。
3. malloc函数
	在给结构体初始化之前，需要先用malloc为其分配空间，否则传入函数的结构体无法被修改（未分配空间时，其得到的内存地址是随机的）
#### 算法的时空分析
1. **队列相关**：出/入队列等，时间复杂度为$O(1)$；检查队列相关操作，最坏情况下需遍历全队列，时间复杂度为$O(1)$。
2. **链表相关**：插入链表为顺序插入，时间复杂度为$O(n)$；涉及改变客户信息的操作时间复杂度均为$O(n)$，与”查找特定客户“时间复杂度相同。
#### 测试结果及分析
最后五行输出了每个客户的等待时间及平均等待时间。
![[Pasted image 20250115232231.png|600]]

---
## 实验三——huffman编码
> 编写一个Huffman编码和解码程序，并用Huffman压缩技术实现对任意文件的压缩和解压缩处理（压缩后文件后缀为.huff，可以解压缩所有后缀名为.huff的文件）。以1个字节为单位进行Huffman编码。

### 算法描述
#### 数据结构
主要使用了二叉树，数组，优先队列，字符到编码的映射：
```c++
struct HTNode {//huffman树的节点
    unsigned char data='o'; // 结点的数据
    int parent=-1;
    int lch=-1;
    int rch=-1; // 双亲结点和孩子结点的下标
    ll weight; // 结点的权值
};

HTNode node[512];//数组存储的哈夫曼树
char filename[30];//文件名
priority_queue<int,vector<int>,cmp>q;//优先队列
map<uchar,string>map1;//储存字符和对应huffman编码的映射关系
```
#### 程序结构
##### 文件相关
1. **读取源文件**`void read_file()`
   判断文件是否为空，并记录文件词频，储存在 `tongji` 数组中，为构建huffman树做准备
2. **将指定位置为1/0**
	`SET_BYTE(value, index) ((value) |= (1 << ((index) ^ 7)))`
	`CLR_BYTE(value, index) ((value) &= (~(1 << ((index) ^ 7))))`
3. **判定指定位是否为0**
	`GET_BYTE(value, index) (((value) & (1 << ((index) ^ 7))) != 0)`
4. **写入目标文件**`wf()`
	用于压缩文件。先将词频表写入目标文件，再读取源文件字符，根据`map1`中映射关系转换为huffman编码后写入目标文件。其中，将8位01串合并为一个字节进行写入。
1. **读取目标文件**`rf()`
	用于读取文件并进行解压缩。压缩文件开头即为词频表，据此构建huffman树；再根据huffman树将文件解码，写入输出文件中。解码过程中通过记录已输出的字符数来判断何时停止解码。
##### huffman相关
1. **构造huffman树**`void HTcst()`
2. **构建 Huffman 树**`void HTcst_1()`
	用于解压缩中重新构建huffman树，其中省略了词频统计，直接用压缩文件信息构建huffman树。
3. **生成huffman编码**`void table()`
### 调试分析
- 将文件中的字符转换为huffman编码：设置一个`char[]`缓存区，根据字符对应的huffman编码用`&`写入缓存区，每满八位就作为一个整体写入文件，如此循环往复，如果最后遇上写不满的情况用全0填充，解压时有字符数判断解压是否结束，故无需担心多余的01串被编译。

### 算法的时空分析
#### 时间复杂度
- **构建 Huffman 树`HTcst 和 HTcst_1`**：$O(n log n)$，其中 n 为字符个数。在构建过程中，需进行 n-1 次合并操作，每次操作都需要在优先队列中取出两个最小权值的节点并插入新节点，而优先队列的插入和删除操作时间复杂度为 $O(log n)$。
- **Huffman 编码`table`**：$O(n)$，对于每个字符，从叶子节点到根节点的路径长度最多为 n-1，因此生成所有字符的 Huffman 编码的总时间复杂度为$O(n^2)$，但在实际应用中，由于字符的分布不均匀，平均路径长度通常远小于 n，所以可以近似认为时间复杂度为$O(n)$。
- **写入目标文件`wf`**：$O(m)$
- **读取目标文件`rf`**：$O(m)$
#### 空间复杂度
- **Huffman 树节点数组`node`**：$O(n)$，数组中存储了 2n-1 个节点，包括 n 个叶子节点和 n-1 个内部节点。
- **字符词频数组`tongji`**：$O(1)$，数组大小固定为 256，与字符个数无关。
- **优先队列`q`**：$O(n)$，优先队列中存储了 n 个节点的下标。
- **字符到编码的映射`map1`**：$O(n)$，映射中存储了 n 个字符及其对应的 Huffman 编码。
### 测试结果及分析

测试中压缩2_3.bmp, 2_4.mp4, 2_5.exe三种文件。下图为压缩前的文件大小及名称
![[64CEP]4`HIN}EX9MXL%AW5S.png | 600]]

下图中分别展示了压缩后的文件和根据压缩文件解压缩的文件，可以看到，压缩后的2_3.bmp和2_4.mp4文件都比源文件的大小要小，实现了压缩功能；而解压缩的文件大小和原来一致，并且格式也相同。
![[IQY7VJK5`4}]XXOS{BIABUX.png | 600]]

---
## 实验四——图相关
> 进行图的创建，图的输出以及DFS/BFS算法遍历图；用Prim和Kruskal算法构建网的最小代价生成树；用Dijkstra算法求铁路交通网（加权网）的最短路径。
### 图的遍历（DFS/BFS）
#### 算法描述
##### 数据结构
主要使用了队列和图的邻接表储存结构:
```c
//队列的定义
typedef struct QueueNode {
    int vertex;
    struct QueueNode *next;
} QueueNode;

// 队列
typedef struct Queue {
    QueueNode *front;
    QueueNode *rear;
} Queue;

//图的定义（邻接表）
typedef struct node { //储存边的结点
    int adjvex;
    struct node *nextarc;
    int *info;
} ArcNode;

typedef struct Node { //储存点的结点（表头）
    int data;
    ArcNode *firstarc;
} VNode, AdjList[MAX_VERTEX_NUM];

typedef struct {
    AdjList vertices;
    int vexnum, arcnum;
    int kind;
} ALGraph;
```
##### 函数结构
###### 队列相关
1. **创建队列**`Queue *createQueue()`
2. **队列判空**`int isQueueEmpty(Queue *queue)`
3. **入/出队**
	`void enqueue(Queue *queue, int vertex)`
	`int dequeue(Queue *queue)`
###### 图相关
1. **创建图**`ALGraph *create_graph(int n, int e)`
2. **添加边**`void addedge(ALGraph *graph, int i, int j)`
3. **深度优先搜索**`void DFS(ALGraph *graph, int first, int visited[])`
	用递归实现深度优先搜索，同时依据`visited[]`决定是否访问对应结点。
4. **广度优先搜索**`void BFS(ALGraph *graph, int first, int visited[])`
	借助队列储存带访问的顶点，逐层访问所有未访问的邻接点。
#### 调试分析
1. **边界条件**：在 `addedge` 函数中，处理顶点编号从 `1` 开始的情况，通过 `i - 1` 和 `j - 1` 转换为从 `0` 开始的索引。
2. **内存泄漏**：在 `dequeue` 和 `addedge` 函数中，确保每次分配的内存都正确释放。
3. **队列操作**：在 `BFS` 函数中，确保队列的入队和出队操作正确，避免队列为空时的错误操作。
#### 算法的时空分析
##### 时间复杂度
- **创建图`create_graph`**：$O(n)$，其中 n 为顶点数。初始化每个顶点的边表指针。
- **添加边`addedge`**：$O(1)$，插入新边的操作是常数时间复杂度。
- **深度优先搜索`DFS`**：$O(n + m)$，其中 n 为顶点数，m 为边数。每个顶点和每条边都访问一次。
- **广度优先搜索`BFS`**：$O(n + m)$，每个顶点和每条边都访问一次。
##### 空间复杂度
- **队列`Queue`** ：$O(n)$，队列中最多存储 n 个顶点。
- **图的邻接表存储结构`ALGraph`**：$O(n + m)$，存储 n 个顶点和 m 条边。
- **访问标记数组`visited`**：$O(n)$，存储每个顶点的访问状态。
### 网的最小代价生成树
> 输入一个无向铁通讯网图，用 Prim 和 Kruskal 算法计算最小生成树并输出。
#### 算法描述
##### 数据结构
主要使用了图的邻接表储存结构和边的链表储存结构：
```c
typedef struct node { // 储存边的结点
    int adjvex;
    struct node *nextarc;
    int info;
} ArcNode;

typedef struct Node { // 储存点的结点（表头）
    int data;
    ArcNode *firstarc;
} VNode, AdjList[MAX_VERTEX_NUM];

typedef struct {
    AdjList vertices;
    int vexnum, arcnum;
    int kind;
} ALGraph;

typedef struct edge { // 用来存放边的权重以及比大小
    int head;
    int dest;
    int num;
    int visited;
    struct edge *next;
} Edge;
```
##### 函数结构
###### 图相关
1. **创建图**`ALGraph *create_graph(int n, int e)`
2. **边的添加/删除**
	`void addedge(ALGraph *graph, int i, int j, int num)
	`void deledge(ALGraph *graph, int i, int j)
3. **DFS**（深度优先搜索）`int DFS(ALGraph *graph, int first, int visited[])
###### 链表相关
1. **插入边**`Edge *EnEdge(Edge *edge, int head, int dest, int num)`
	将权重为num的边按照从小到大插入链表中
###### Kruskal算法
> `void Kruskal(Edge *edge, int n, int e, int visited[])`

首先将所有边从小到大排序，再构建一个新图，每次放入不在此图中的最小边，并在该图中进行DFS，若全程无重复访问结点，则认为不构成回路。重复该操作直到遍历所有边，最后再用DFS遍历该图，得到最小生成树的代价。
###### Prim算法
> `void Prim(ALGraph *graph, Close close[])`

将顶点分为两类，一类在生成树中，一类不在。每次选取连接两类点的边中权值最小的边，将该边和对应的点加入到生成树中，重复操作直到所有点都进入生成树中。同时，记录加入生成树的边的求和，即可得到最小生成树的代价。
#### 调试分析
1. Prim和Kruskal都需要查找最小权值的路径，故需要设置一个min变量，而每次循环结束，应将min重置（置为大数），用于下一轮查找。
2. c语言中函数变量声明：应当统一放在最前面，否则在函数中变量声明会被误以为是表达式而发生运行错误。
#### 算法的时空分析
##### Kruskal算法
- **时间复杂度**：主要操作是对边进行排序，时间复杂度为O(ElogE)，其中E为边数。在遍历边的过程中，使用深度优先搜索检测回路的时间复杂度为O(V+E)，其中V为顶点数。因此，Kruskal算法的总时间复杂度为O(ElogE+V+E)。
- **空间复杂度**：需要存储图的邻接表结构，空间复杂度为O(V+E)。此外，还需要一个边的链表来存储排序后的边，空间复杂度为O(E)。所以，Kruskal算法的空间复杂度为O(V+2E)。
##### Prim算法
- **时间复杂度**：在Prim算法中，需要对每个顶点进行最小边的选择，时间复杂度为O(V^2)。对于每个顶点，还需要遍历其所有相邻的边来更新`close`数组，时间复杂度为O(E)。因此，Prim算法的总时间复杂度为O(V^2+E)。
- **空间复杂度**：Prim算法同样需要存储图的邻接表结构，空间复杂度为O(V+E)。此外，还需要一个`close`数组来存储与最小生成树相邻的顶点信息，空间复杂度为O(V)。所以，Prim算法的空间复杂度为O(V+E)。
### Dijkstra算法
> 输入一个无向铁路交通图、始发站和终点站，用 Dijkstra 算法计算从始发 站到终点站的最短路径。
#### 算法描述
##### 数据结构
主要使用了图的邻接表储存结构，以及定义了一个结构体用以记录路径：、
```c
typedef struct node { //储存边的结点
	int adjvex;
	struct node *nextarc;
	int info;
} ArcNode;

typedef struct Node { //储存点的结点（表头）
	int data;
	ArcNode *firstarc;
} VNode, AdjList[MAX_VERTEX_NUM];

typedef struct {
	AdjList vertices;
	int vexnum, arcnum;
	int kind;
} ALGraph;

typedef struct {
	int num;
	int visited;
} Route;
```
##### 函数结构
###### 图相关
1. **创建图`ALGraph *create_graph(int n, int e)`**
2. **添加/删除边**
	`void addedge(ALGraph *graph, int i, int j, int num)`
	`void deledge(ALGraph *graph, int i, int j)`
###### Dijkstra算法
> `void Dijkstra(ALGraph *graph, int begin, int end, Route route[])`

首先将初始顶点`begin`存放至一个集合`S`中，`route[]`用于记录从该点到每个顶点的最短路径长度，除`route[begin]`外初始值均设为无穷大。然后从未加入`S`中的点中，找到对应`route[]`最小的顶点，加入`S`,并更新`route[]`。如此直到所有顶点都被加入`S`.最终根据`end`输出对应最小值即可。
#### 调试分析
#### 算法的时空分析
##### 时间复杂度
1. **初始化**：初始化所有顶点的距离和访问标记，时间复杂度为O(V)，其中V为顶点数。
2. **主循环**：算法的主循环需要进行V次，每次选择一个未访问的顶点，该顶点到源点的距离最小。选择最小距离的顶点的时间复杂度为O(V)，更新该顶点的所有邻接顶点的距离的时间复杂度为O(E)，其中E为边数。因此，主循环的总时间复杂度为O(V^2 + E)。
综上，Dijkstra算法的总时间复杂度为O(V^2 + E)。
##### 空间复杂度
1. **图的邻接表**：存储图的邻接表结构，空间复杂度为O(V + E)。
2. **路径记录数组**：存储每个顶点到源点的最短路径长度和访问标记，空间复杂度为O(V)。
综上，Dijkstra算法的总空间复杂度为O(V + E)。
### 测试结果及分析
#### 图的遍历
##### DFS
![[Pasted image 20250115230751.png | 600]]
##### BFS
![[Pasted image 20250115230849.png|600]]
#### 最小代价生成树
##### Prim
![[Pasted image 20250115231501.png]]
##### Kruskal
![[Pasted image 20250115231351.png | 600]]
#### Dijkstra
![[Pasted image 20250115231704.png|600]]

---
## 实验五——hash表
> 1. 用除留余数法构建哈希函数，用线性探测法解决冲突，构建哈希表 HT1； 
> 2. 用除留余数法构建哈希函数，用拉链法解决冲突，构建哈希表 HT2；
> 3. 分别对 HT1 和 HT2 计算在等概率情况下查找成功和查找失败的 ASL；
> 4. 分别在 HT1 和 HT2 中查找给定的关键字，给出比较次数
### 算法描述
#### 数据结构
##### 线性探测法的哈希表
```c
typedef struct hash {
    int *elem; // 储存基址
    int count; // 储存的值的个数
    int length; // 哈希表长度
} Hash;
```
##### 拉链法的哈希表
```c
typedef struct HashNode {
    int data;
    struct HashNode *next;
} HashNode;

typedef struct HashTable {
    HashNode** table;
    int size;
} HashTable;
```
#### 函数结构
##### 哈希函数
```c
int Function_hash(int x, int p) {
    int result = 0;
    result = x % p;
    return x;
}
```
##### 线性探测法相关
1. **hash表创建**`Hash* create_hash(int length)`
2. **hash表插入**`void insert_hash(int key, int p, Hash* hash)`
3. **查找键值`key`，返回查找次数**`int search_hash(int key, int p, Hash *hash)`
4. **平均查找长度计算**`int ASL_true_hash(Hash* hash, int p, int num[], int n)`
	对数组`num`中的每个元素，在哈希表中查找，累加查找次数，最后除以**元素个数`n`**
5. **失败查找的平均查找长度**`int ASL_false_hash(Hash* hash)`
	对于哈希表中的每个位置，从该位置开始，依次向后查找空位，累加查找次数，最后除以**哈希表长度**。
##### 拉链法相关
1. **初始化**`void initHashTable(HashTable* table, int size)`
2. **创建结点**`HashNode* createNode(int data)`
4. **将`data`插入hash表**`void insertHashTable(HashTable* table, int data, int p)`
5. **查找`key`，返回查找次数**`int search_hashtable(int key, int p, HashTable *hashtable)`
6. **平均查找长度计算**`int ASL_true_hashtable(HashTable* hashtable, int p, int num[], int n)`
	对数组`num`中的每个元素，在哈希表中查找，累加查找次数，最后除以**元素个数**`n`
7. **失败查找的平均查找长度**`int ASL_false_hashtable(HashTable* hashtable)`
	对于哈希表中的每个位置，从该位置开始，依次遍历链表，累加链表长度，最后除以**哈希表大小**。
### 调试分析
1. 注意result应当被定义为float类型变量，因此函数需要返回float类型，printf需要用%f。
2. 查找**失败长度**：查找一个hash表中不存在的值，所花费的“解决冲突”的次数。所以，查找失败长度不需要用到原始的关键字数组，只需要对hash表本身遍历即可。
### 算法的时空分析
#### 1. 线性探测法
##### 时间复杂度
- **插入操作**：平均时间复杂度为O(1)，但在最坏情况下（哈希表接近满时）可能退化为O(n)。
- **查找操作**：成功查找的平均时间复杂度为O(1)，失败查找的平均时间复杂度为O(n)。
- **计算ASL**：成功查找的ASL计算时间复杂度为O(n)，失败查找的ASL计算时间复杂度为O(n)。
##### 空间复杂度
- **哈希表**：O(n)，其中n为哈希表的长度。
#### 2. 拉链法的哈希表
##### 时间复杂度
- **插入操作**：平均时间复杂度为O(1)，在最坏情况下（所有元素都映射到同一个桶）可能退化为O(n)。
- **查找操作**：成功查找的平均时间复杂度为O(1)，失败查找的平均时间复杂度为O(1)。
- **计算ASL**：成功查找的ASL计算时间复杂度为O(n)，失败查找的ASL计算时间复杂度为O(n)。
##### 空间复杂度
- **哈希表**：O(n)，其中n为哈希表的长度。
- **链表**：O(m)，其中m为插入的元素个数。
### 测试结果及分析
#### 线性探测法
按照实验要求输入后，直观得出了哈希表的结构及对应查找次数。
![[Pasted image 20250115230226.png | 600]]
#### 拉链法
因为拉链法采用链表处理冲突，故在输出时转换了输出方式，将其按照序号一排一排输出。同样可直观表现hash表结构。
![[Pasted image 20250115230358.png | 600]]
## 体会与收获
### 实验一
 > 作为数据结构的第一个实验，使用链表和指针实现多项式计算器也算是意料之中，上学期基本没碰c语言，所以第一个实验实现起来尤其的困难，许多链表相关的操作都有些忘记了。

1. 锻炼了链表相关的操作，如插入/修改节点等
2. 重新熟悉了C语言
### 实验二
> 对栈和队列的使用进行了很好的锻炼

1. 栈和队列本质上是起缓存作用。
### 实验三
> 最难的不在huffman编码，最难的在如何将01串按位写入文件

1. 了解了用二叉树构建huffman数，以及据此建立映射的操作
2. 重新熟悉了写入文件、用`&`进行按位写入的操作
### 实验四
> 熟悉了图这一章节的经典算法：Prim、Kruskal、Dijkstra

并没有想象中那么难，实际上手起来都有贪心算法的影子，通过遍历和循环/递归总可以达到目的。
### 实验五
> hash表相关操作

hash表应该被叫做”函数表“，本质上是建立映射来查找。而此次实验中的关键字就是数字本身，故一定程度上减轻了代码难度，如果额外设置关键字的话，则结构体需再定义一个空间储存，操作上也要增多。整体来讲，考虑到接近期末周，这样的一个实验还是很仁慈的。
## 附录
### 实验一——稀疏一元多项式计算
```c
#include <stdio.h>

#include <stdlib.h>

#include <math.h>

#define MAX_POLYS 5

  

typedef struct PolyNode {

    float coef; // 系数

    int exp;    // 指数

    struct PolyNode *next;

} PolyNode;

  

typedef struct {

    PolyNode *head;

    int count; // 项数

} Polynomial;

  

// 创建多项式节点

PolyNode *createNode(float coef, int exp) {

    PolyNode *node = (PolyNode *)malloc(sizeof(PolyNode));

    node->coef = coef;

    node->exp = exp;

    node->next = NULL;

    return node;

}

  

// 插入节点到多项式

void insertNode(Polynomial *poly, float coef, int exp) {

    PolyNode *node = createNode(coef, exp);

    if (poly->head == NULL || exp < poly->head->exp) {

        node->next = poly->head;

        poly->head = node;

    } else {

        PolyNode *current = poly->head;

        PolyNode *prev = NULL;

        while (current != NULL && current->exp < exp) {

            prev = current;

            current = current->next;

        }

        if (current != NULL && current->exp == exp) {

            // 修改已有结点

            current->coef += coef;

            if (current->coef == 0) {//处理相加为0

                if (prev) {

                    prev->next = current->next;

                }

                //不懂下面这个else是干啥的，遂注释掉

                // else {

                //     poly->head = current->next;

                // }

                free(current);

            }

        } else {

            node->next = prev->next;

            prev->next = node;

  

            //node->next = current;

            //if (prev) {

            //  prev->next = node;

            //}

        }

    }

    poly->count++;

}

  

// 输出多项式

void printPolynomial(Polynomial *poly) {

    PolyNode *current = poly->head;

    printf("多项式项数: %d\n", poly->count);

    while (current != NULL) {

        if (current->coef > 0 && current != poly->head) {//考虑了负号的情形

            printf("+");

        }

        if (current->exp != 0) {

  

            printf("%g*x^%d ", current->coef, current->exp);

        } else

            printf("%g ", current->coef);

        current = current->next;

    }

    printf("\n");

}

  

// 销毁多项式

void destroyPolynomial(Polynomial *poly) {

    PolyNode *current = poly->head;

    while (current != NULL) {

        PolyNode *temp = current;

        current = current->next;

        free(temp);

    }

    poly->head = NULL;

    poly->count = 0;

}

  

// 清空多项式,感觉两个差别不大

void clearPolynomial(Polynomial *poly) {

    destroyPolynomial(poly);

}

  

// 求和

Polynomial addPolynomial(Polynomial *poly1, Polynomial *poly2) {

    Polynomial result;

    result.head = NULL;

    result.count = 0;

  

    PolyNode *current1 = poly1->head;

    PolyNode *current2 = poly2->head;

  

    while (current1 != NULL || current2 != NULL) {

        if (current1 != NULL && (current2 == NULL || current1->exp > current2->exp)) {

            insertNode(&result, current1->coef, current1->exp);

            current1 = current1->next;

        } else if (current2 != NULL && (current1 == NULL || current2->exp > current1->exp)) {

            insertNode(&result, current2->coef, current2->exp);

            current2 = current2->next;

        } else if (current1 != NULL && current2 != NULL && current1->exp == current2->exp) {

            float sum = current1->coef + current2->coef;

            if (sum != 0) {

                insertNode(&result, sum, current1->exp);

            }

            current1 = current1->next;

            current2 = current2->next;

        }

    }

    return result;

}

  

// 求差,本质上只要将求和中coef改成负的就可以了

Polynomial subtractPolynomial(Polynomial *poly1, Polynomial *poly2) {

    Polynomial result;

    result.head = NULL;

    result.count = 0;

  

    PolyNode *current1 = poly1->head;

    PolyNode *current2 = poly2->head;

  

    while (current1 != NULL || current2 != NULL) {

        if (current1 != NULL && (current2 == NULL || current1->exp > current2->exp)) {

            insertNode(&result, current1->coef, current1->exp);

            current1 = current1->next;

        } else if (current2 != NULL && (current1 == NULL || current2->exp > current1->exp)) {

            insertNode(&result, -current2->coef, current2->exp);

            current2 = current2->next;

        } else if (current1 != NULL && current2 != NULL && current1->exp == current2->exp) {

            float diff = current1->coef - current2->coef;

            if (diff != 0) {

                insertNode(&result, diff, current1->exp);

            }

            current1 = current1->next;

            current2 = current2->next;

        }

    }

    return result;

}

  

// 求值

float evaluatePolynomial(Polynomial *poly, float x) {

    float result = 0;

    PolyNode *current = poly->head;

    if (current == NULL) {

        printf("没有多项式\n");

        return 0;

    }

    while (current != NULL) {

        result += current->coef * pow(x, current->exp);

        current = current->next;

    }

    return result;

}

  

// 微分

Polynomial differentiatePolynomial(Polynomial *poly) {

    Polynomial result;

    result.head = NULL;

    result.count = 0;

  

    PolyNode *current = poly->head;

    while (current != NULL) {

        if (current->exp > 0) {

            insertNode(&result, current->coef * current->exp, current->exp - 1);

        }

        current = current->next;

    }

    return result;

}

  

// 不定积分

Polynomial indefiniteIntegralPolynomial(Polynomial *poly) {

    Polynomial result;

    result.head = NULL;

    result.count = 0;

  

    PolyNode *current = poly->head;

    while (current != NULL) {

        if (current->exp >= 0) {

            insertNode(&result, current->coef / (current->exp + 1), current->exp + 1);

        }

        current = current->next;

    }

    return result;

}

  

// 主函数

int main() {

    Polynomial poly1, poly2, result;

    poly1.head = NULL, poly2.head = NULL;

    poly1.count = 0;

    int exp = 0, exp1 = 0, exp2, k = 0, i = 0, j = 0, n = 0,

        l = 0, m = 0; //j用于switch判断，l用于8中的二级菜单,m是8中的三级菜单,exp1用于查找指数,exp2用于修改指数

    int a[5];

    for (i = 0; i < 5; i++) {

        a[i] = 0;

    }

    double coef = 0, x = 0, up = 0, down = 0, coef1 = 0,

           coef2 = 0; //up是积分上限，down是积分下限，x是未知量,coef1用于查找系数,coef2用于修改系数

  

//在这里搞一下存多项式的功能

    Polynomial *polyArray[MAX_POLYS];

    for (i = 0; i < MAX_POLYS; i++) {

        polyArray[i] = (Polynomial *)malloc(sizeof(Polynomial));

        if (polyArray[i] == NULL) {

            fprintf(stderr, "内存分配失败\n");

            return 1;

        }

        polyArray[i]->head = NULL;  // 初始化头指针为NULL

        polyArray[i]->count = 0;    // 初始化计数为0

    }

  
  

    while (j != 12) {

        //printf("请选择进行操作的多项式（输入数字）\n");

        //scanf("%d", &i);

        //polyArray[i]->head = poly1.head;

        printf("请选择功能:\n1.创建多项式\n2. 输出多项式\n3. 求和\n4. 求差\n5. 求值\n6. 销毁\n7. 清空\n8. 修改\n9. 微分\n10. 不定积分\n11. 定积分\n12. 退出\n");

        scanf("%d", &j);

        switch (j) {

            case 1:

                printf("请选择进行存放的多项式序号（输入数字1~5）\n");

                scanf("%d", &i);

                if (polyArray[i - 1]->head != NULL) {

                    printf("已创建多项式\n");

                    break;

                }

                printf("请输入多项式项数:");//这里调试的有问题，我觉得我要寄掉

                scanf("%d", &k);

                for (n = 0; n < k; n++) {

                    printf("\n请输入第%d项系数:", (n + 1));

                    scanf("%lf", &coef);

                    printf("\n请输入第%d项次数：", (n + 1));

                    scanf("%d", &exp);

                    insertNode(polyArray[i - 1], coef, exp);

                    printf("\n");

                }

  

                break;

            case 2://这里还没有把无多项式的情况讨论了

                printf("请选择进行输出的多项式序号");

                scanf("%d", &i);

                if (polyArray[i - 1]->count == 0) {

                    printf("没有多项式\n");

                    break;//不知道这里对不对

                }

  

                printPolynomial(polyArray[i - 1]);

                break;

            case 3:

                printf("请选择：\n1.与现有多项式相加\n2.与新增多项式相加\n");

                m = 0;

                k = 0;

                n = 0;

                scanf("%d", &m);

                switch (m) {

                    case 1: {

                        printf("请选择相加个数(2~5)");

                        scanf("%d", &k);

                        for (n = 0; n < k; n++) {

                            printf("第%d项是", n + 1);

                            scanf("%d", &a[n]);

                        }

                        result = addPolynomial(polyArray[a[0] - 1], polyArray[a[1] - 1]);

                        for (n = 2; n < k; n++) {

                            result = addPolynomial(&result, polyArray[a[n]]);

                        }

                        printf("求和结果: ");

                        printPolynomial(&result);

                        destroyPolynomial(&result);

                        break;

                    }

                    case 2: {

                        printf("请选择多项式（1~5）");

                        scanf("%d", &i);

  
  

                        printf("请输入相加多项式项数:");//先建立相加的多项式

                        scanf("%d", &k);

                        for (n = 0; n < k; n++) {

                            printf("\n请输入第%d项系数:", (n + 1));

                            scanf("%lf", &coef);

                            printf("\n请输入第%d项次数：", (n + 1));

                            scanf("%d", &exp);

                            insertNode(&poly2, coef, exp);

                            printf("\n");

                        }

                        result = addPolynomial(polyArray[i - 1], &poly2);

                        printf("求和结果: ");

                        printPolynomial(&result);

                        destroyPolynomial(&result);

                        break;

                    }

                }

                break;

            case 4:

                printf("请选择：\n1.现有多项式相减\n2.新增多项式相减\n");

                m = 0;

                k = 0;

                n = 0;

                scanf("%d", &m);

                switch (m) {

                    case 1: {

                        printf("减的多项式是");

                        scanf("%d", &a[0]);

                        printf("被减的多项式是");

                        scanf("%d", &a[1]);

                        result = subtractPolynomial(polyArray[a[0] - 1], polyArray[a[1] - 1]);

                        printf("求差结果: ");

                        printPolynomial(&result);

                        destroyPolynomial(&result);

                        break;

                    }

                    case 2: {

                        printf("请选择多项式（1~5）");

                        scanf("%d", &i);

                        printf("请输入相减多项式项数:");//先建立相减的多项式

                        scanf("%d", &k);

                        for (n = 0; n < k; n++) {

                            printf("\n请输入第%d项系数:", (n + 1));

                            scanf("%lf", &coef);

                            printf("\n请输入第%d项次数：", (n + 1));

                            scanf("%d", &exp);

                            insertNode(&poly2, coef, exp);

                            printf("\n");

                        }

                        result = subtractPolynomial(polyArray[i - 1], &poly2);

                        printf("求差结果: ");

                        printPolynomial(&result);

                        destroyPolynomial(&result);

                        break;

                    }

                    break;

                }

                break;

            case 5://求值

                printf("请选择进行操作的多项式序号");

                scanf("%d", &i);

  

                if (polyArray[i - 1]->count == 0) {

                    printf("没有多项式");

                    return 0;

                }

                printf("请输入x的值");

                scanf("%lf", &x);

                printf("多项式在x=%g处的值: %g\n", x, evaluatePolynomial(polyArray[i - 1], x));

                break;

            case 6:

                printf("请选择进行操作的多项式序号");

                scanf("%d", &i);

                destroyPolynomial(polyArray[i - 1]);

                printf("多项式已销毁\n");

                break;

            case 7:

                printf("请选择进行操作的多项式序号");

                scanf("%d", &i);

                destroyPolynomial(polyArray[i - 1]);

                printf("多项式已清空\n");

                break;

            case 8://修改多项式

                printf("请选择修改功能\n1. 插入新节点\n2. 删除已有节点\n3. 修改已有节点系数\n4.修改已有节点指数");

                scanf("%d", &l);

                switch (l) {

                    case 1: { //插入新节点

                        printf("请选择进行操作的多项式序号");

                        scanf("%d", &i);

                        printf("\n请输入插入新节点系数：");

                        scanf("%lf", &coef);

                        printf("\n请输入插入新节点指数：");

                        scanf("%d", &exp);

                        insertNode(polyArray[i - 1], coef, exp);

                        printf("\n");

                        break;

                    }

                    case 2: { //删除已有节点

                        printf("请选择进行操作的多项式序号");

                        scanf("%d", &i);

                        if (polyArray[i - 1]->count == 0) {

                            printf("没有多项式\n");

                            break;

                        }

                        printPolynomial(polyArray[i - 1]);

                        printf("请输入删除的项指数：");

                        scanf("%d", &exp1);

                        PolyNode *current = polyArray[i - 1]->head; //建立临时指针查找

                        PolyNode *prev = NULL;

                        while (current != NULL && current->exp != exp1) {

                            prev = current;

                            current = current->next;

                        }

                        if (current != NULL && current->exp == exp1) {

                            if (prev == NULL) { // 如果是头节点

                                polyArray[i - 1]->head = current->next;

                            } else {

                                prev->next = current->next;

                            }

                            free(current);

                            printf("修改成功\n");

                            polyArray[i - 1]->count--;

                        } else {

                            printf("找不到该节点\n");

                        }

                        break;

                    }

                    case 3: { //系数修改

                        printf("请选择进行操作的多项式序号");

                        scanf("%d", &i);

                        if (polyArray[i - 1]->count == 0) {

                            printf("没有多项式\n");

                        } else {

                            printPolynomial(polyArray[i - 1]);

                            printf("请输入修改的项指数：");

                            scanf("%d", &exp1);

                            PolyNode *current = polyArray[i - 1]->head; //建立临时指针查找

                            PolyNode *prev = NULL;

                            while (current != NULL && current->exp != exp1) {

                                prev = current;

                                current = current->next;

                            }

                            if (current == NULL) {

                                printf("查无此节点\n");

                            } else {

                                printf("将系数修改为:");

                                scanf("%lf", &coef2);

                                if (coef2 == 0) { //相当于删除操作

                                    if (prev == NULL) { // 如果是头节点

                                        polyArray[i - 1]->head = current->next;

                                    } else {

                                        prev->next = current->next;

                                    }

                                    free(current);

                                    printf("修改成功\n");

                                    poly1.count--;

                                } else {

                                    current->coef = coef2;

                                    printf("修改成功\n");

                                }

                            }

                        }

                        break;

                    }

                    case 4: { //指数修改

                        printf("请选择进行操作的多项式序号");

                        scanf("%d", &i);

                        if (polyArray[i - 1]->count == 0) {

                            printf("没有多项式\n");

                            break;

                        }

                        printPolynomial(polyArray[i - 1]);

                        printf("请输入修改的项系数：");

                        scanf("%lf", &coef1);

                        PolyNode *current1 = polyArray[i - 1]->head; //建立临时指针查找

                        PolyNode *prev1 = NULL;

                        while (current1 != NULL && current1->coef != coef1) {

                            prev1 = current1;

                            current1 = current1->next;

                        }

                        if (current1 == NULL) {

                            printf("查无此节点\n");

                            break;

                        } else {

                            printf("将指数修改为:");

                            scanf("%d", &exp2);

                            if (exp2 == current1->exp) {

                                printf("你没有做出修改\n");

                                break;

                            }

                            prev1->next = current1->next;

                            free(current1);

                            insertNode(polyArray[i - 1], coef1, exp2);

                            printf("修改成功");

                        }

                        break;

                    }

                }

                break;//跳出case8

            case 9://微分

                j = 0;

                printf("请选择进行操作的多项式序号");

                scanf("%d", &i);

                if (polyArray[i - 1]->count == 0) {

                    printf("没有多项式");

                    return 0;

                }

                printf("求导次数:");

                scanf("%d", &j);

                result = differentiatePolynomial(polyArray[i - 1]);

                for (i = 1; i < j; i++)

                    result = differentiatePolynomial(&result);

                printf("微分结果: ");

                printPolynomial(&result);

                destroyPolynomial(&result);;

                break;

            case 10://不定积分

                printf("请选择进行操作的多项式序号");

                scanf("%d", &i);

                result = indefiniteIntegralPolynomial(polyArray[i - 1]);

                printf("不定积分结果: ");

                printPolynomial(&result);

                destroyPolynomial(&result);

                break;

            case 11://定积分

                printf("请选择进行操作的多项式序号");

                scanf("%d", &i);

                result = indefiniteIntegralPolynomial(polyArray[i - 1]);

                printf("请输入积分上限:");

                scanf("%lf", &up);

                printf("\n请输入积分下限:");

                scanf("%lf", &down);

                printf("\n定积分结果:%lf ", evaluatePolynomial(&result, up) - evaluatePolynomial(&result, down));

                break;

            case 12:

                exit(0);

  

        }

    }

}
```
### 实验二——栈与队列
#### 银行业务模拟
```c
//银行业务模拟
#include <stdio.h>
#include <stdlib.h>

#define OVERFLOW -1
#define ERROR -1

typedef struct Customer {
	double time;//用户到来时间
	double wait;//用户等待时间
	int finish;//判断是否完成
	struct Customer *next;
} Customer;

typedef struct QNode { //定义队列
	double money;//需要的钱（有正负）
	double time;//用户到来的时间
	double wait;
	int finish;//判断操作是否完成
	struct QNode *next;
} QNode, * QueuePtr;

typedef struct {
	QueuePtr front;//头
	QueuePtr rear;//尾
} LinkQueue;

void InitQueue(LinkQueue *queue) { //队列初始化
	queue->front = queue->rear = (QNode *)malloc(sizeof(QNode));
	if (!queue)
		exit(OVERFLOW);
	queue->front->next = NULL;
}

void EnQueue(LinkQueue *queue, double money, double time) { //将客户插入队列
	QNode *qnode = (QueuePtr)malloc(sizeof(QNode));
	if (!qnode)
		exit(OVERFLOW);
	qnode->money = money;
	qnode->time = time;
	qnode->next = NULL;
	queue->rear->next = qnode;
	queue->rear = qnode;
}

void Initcustomer(Customer *custmer) { //链表初始化
	custmer = (Customer *)malloc(sizeof(Customer));
	custmer->next = NULL;
}

void Encustomer(Customer **customer, double time) { //插入客户进链表
	Customer *temp = (Customer *)malloc((sizeof(Customer)));
	Customer *current = *customer;
	temp->time = time;
	temp->finish = 0;
	temp->wait = 0;
	temp->next = NULL;

	if (*customer == NULL) {
		*customer = temp;

	} else {
		while (current->next != NULL) {
			current = current->next;
		}
		current->next = temp;
	}
}

void addtime(Customer **customer, double average_time, double real_time) { //增加客户的等待时间
	Customer *current = *customer;

	while (current->next != NULL) {

		if (current->finish == 0 && (current->time <= (real_time + average_time))) { //在客户办理结束之前来都要等待
			current->wait = current->wait + (average_time - (current->time + current->wait - real_time));
		}
		current = current->next;
	}
}

void addtime1(Customer **customer, double time,
              double real_time) { //用于在real_time<time时计算等待时间（这个时候不用等）
	Customer *current = *customer;
	while (current->time != time) {
		current = current->next;
	}
	current->wait = 0;
}

void addtime2(Customer **customer, double time,
              double real_time) { //用于在real_time>time时计算等待时间（这个时候不用等）
	Customer *current = *customer;
	while (current->time != time) {
		current = current->next;
	}
	current->wait = real_time - time;
}

void finish_cust1(Customer *customer, double time) { //将某客户状态标为完成
	Customer *current = customer;

	while (current->time != time && current != NULL) {
		current = current->next;
	}
	current->finish = 1;
}

double finish_cust(Customer *customer, double time, double real_time,
                   double average_time) { //将某个客户的状态标为完成,返回该用户等待时间
	Customer *current = customer;

	while (current->time != time && current != NULL) {
		current = current->next;
	}
	if (current == NULL)
		return ERROR;
	current->finish = 1;
	current->wait = real_time  - current->time;
	return current->wait;
}

double DeQueue(LinkQueue *queue) { //弹出队首的钱
	QNode *current = NULL;
	double e;
	if (queue->front == queue->rear)
		return ERROR;
	current = queue->front->next;
	e = current->money;
	queue->front->next = current->next;
	if (queue->rear == current)
		queue->rear = queue->front; //防止刚好只有一个元素时current和rear重合，此时将rear指向front
	free(current);
	return e;
}

double check_queue(LinkQueue *queue, double total, double past_total, Customer *customer, double average_time,

                   double *real_time) { //检查第二个队列,顺便修改total的值
	if (queue->front == queue->rear)
		return total;//如果还没有队列就不检查了

	else {
		QNode *current = NULL;
		double money;
		double user_time;
		double wait;
		double first_time;//用于记录第一个无法取钱的（用于结束的判断）
		current = queue->front->next;
		money = current->money;
		user_time = current->time;

		while ((money + total) >= 0 && (money + total) >= past_total) { //先得到第一个被插入队尾的客户

			total = total + money;
			if (*real_time <= user_time) {
				addtime1(&customer, user_time, *real_time);
				*real_time = user_time + average_time;
			} else {
				addtime2(&customer, user_time, *real_time);
				*real_time = *real_time + average_time;
			}
			if (queue->rear == current) { //处理只有一个节点的情况
				queue->rear = queue->front;
				free(current);
				return total;
			}

			current = current->next;
			money = current->money;
			user_time = current->time;
		}

		if ((money + total) < 0) {
			first_time = user_time;
			current = current->next;
			DeQueue(queue);//弹出再插入队尾
			EnQueue(queue, money, user_time);
			money = current->money;
			user_time = current->time;
		}

		while ((queue->front != queue->rear) && (current->time != first_time)) {

			if (((money + total) >= 0) && (money + total) < past_total) { //满足停止检查的第二个条件,释放完这个结点就停止
				DeQueue(queue);
				total = total + money;
				if (*real_time <= user_time) {
					addtime1(&customer, user_time, *real_time);
					*real_time = user_time + average_time;
				} else {
					addtime2(&customer, user_time, *real_time);
					*real_time = *real_time + average_time;
				}
				return total;

			} else if (((money + total) < 0)) {
				current = current->next;
				DeQueue(queue);//弹出再插入队尾
				EnQueue(queue, money, user_time);
				money = current->money;
				user_time = current->time;
				//DeQueue(queue);//弹出再插入队尾
				//EnQueue(queue, money, user_time);

			} else if (((money + total) >= 0) && (money + total) >= past_total) {

				total = total + money;
				if (*real_time <= user_time) {
					addtime1(&customer, user_time, *real_time);
					*real_time = user_time + average_time;
				} else {
					addtime2(&customer, user_time, *real_time);
					*real_time = *real_time + average_time;
				}
				current = current->next;
				money = current->money;
				user_time = current->time;

				DeQueue(queue);
			}
		}
		return total;
	}
}

double check_queue_last(LinkQueue *queue, double total, double past_total, Customer *customer, double average_time,

                        double *real_time) { //检查第二个队列,顺便修改total的值
	if (queue->front == queue->rear)
		return 0;//如果还没有队列就不检查了

	else {
		QNode *current = NULL;
		double money;
		double user_time;
		double wait;
		double first_time;//用于记录第一个无法取钱的（用于结束的判断）
		current = queue->front->next;
		money = current->money;
		user_time = current->time;

		while ((money + total) >= 0 && (money + total) >= past_total) { //先得到第一个被插入队尾的客户

			total = total + money;
			if (*real_time <= user_time) {
				addtime1(&customer, user_time, *real_time);
				*real_time = user_time + average_time;
			} else {
				addtime2(&customer, user_time, *real_time);
				*real_time = *real_time + average_time;
			}
			if (queue->rear == current) { //处理只有一个节点的情况
				queue->rear = queue->front;
				free(current);
				return total;
			}

			current = current->next;
			money = current->money;
			user_time = current->time;
		}

		if ((money + total) < 0) {
			first_time = user_time;
			current = current->next;
			DeQueue(queue);//弹出再插入队尾
			EnQueue(queue, money, user_time);
			if (queue->front->next == queue->rear) { //防止此时仅剩一个元素而使得current被释放了
				current = queue->rear;
			}

		}

		while ((queue->front != queue->rear) && (current->time != first_time)) {

			if (((money + total) < 0)) {
				DeQueue(queue);//弹出再插入队尾
				EnQueue(queue, money, user_time);
			} else if (((money + total) >= 0)) {

				total = total + money;
				if (*real_time <= user_time) {
					addtime1(&customer, user_time, *real_time);
					*real_time = user_time + average_time;
				} else {
					addtime2(&customer, user_time, *real_time);
					*real_time = *real_time + average_time;
				}
				if (queue->rear == current) { //处理只有一个节点的情况
					queue->rear = queue->front;
					free(current);
					return total;
				}
				current = current->next;
				money = current->money;
				user_time = current->time;
			}
		}
		return 0;
	}
}

void print_cust(Customer *customer) { //输出链表
	Customer *current = customer;
	double total_time = 0;
	int N = 0;

	while (current != NULL) {
		printf("%lf\n", current->wait);
		total_time = total_time + current->wait;
		N++;
		current = current->next;
	}
	total_time = total_time / N;
	printf("%lf", total_time);
}

void finfish_queue(LinkQueue *queue, double close_time, Customer *customer) { //将表中剩下的客户全部标为完成
	QNode *current = queue->front->next;
	Customer *current1 = customer;
	double time;
	time = current->time;

	while (current != NULL) {

		while (current1->time != time && current1 != NULL) {
			current1 = current1->next;
		}
		current1->wait = close_time - current1->time;
		current1 = customer;
		current = current->next;
	}

}

int main() {
	double close_time = 600, time = 0, average_time, user_time;
	double wait;
	double real_time = 0; //time用作临时变量，cost为当前耗费的时间,user_time为用户到来时间,real_time用于记录系统时间
	double money;
	int N, i; //来银行的人数;用以计数
	double total = 10000, past_total = 10000; //total是银行一开始有的钱，past_total用于判断是否结束第二队列的审查
	LinkQueue *queue1 = (LinkQueue *)malloc(sizeof(LinkQueue)),
	           *queue2 = (LinkQueue *)malloc(sizeof(LinkQueue)); //代表队列1和队列2以及所有的客户队列
	Customer *customer = NULL;
	InitQueue(queue1);
	InitQueue(queue2);
	//Initcustomer(customer);

	printf("请输入N total close_time average_time\n");
	scanf("%d %lf %lf %lf", &N, &total, &close_time, &average_time);
	printf("请输入“客户办理的款额”以及“用户到来的时间”(用空格分开)\n");

	for (i = 0; i < N; i++) { //将客户读入第一个队列和客户链表
		scanf("%lf %lf", &money, &user_time);

		if (user_time <= close_time) { //超出营业时间的不受理
			Encustomer(&customer, user_time);
			EnQueue(queue1, money, user_time);
		} else
			exit(ERROR);
		getchar();
	}
	if ((queue1->front->next->money) > 0) { //如果第一个客户存钱，先给他存完(避免检查)
		time = queue1->front->time;
		money = DeQueue(queue1);
		//wait = finish_cust(customer, time, real_time, average_time);
		//addtime(&customer, average_time, real_time);
		addtime1(&customer, time, 0);
		finish_cust1(customer, time);
		real_time = time + average_time; //系统时间增加
		N = N - 1; //修改客户数量
	}

	for (i = 0; i < N; i++) {
		time = queue1->front->next->time;
		money = DeQueue(queue1);

		if ((money) >= 0) { //接下来判断取/存钱
			past_total = total;
			total = total + money;
			if (real_time <= time) {
				addtime1(&customer, time, real_time);
				real_time = time + average_time;
			} else {
				addtime2(&customer, time, real_time);
				real_time = real_time + average_time;
			}
			total = check_queue(queue2, total, past_total, customer, average_time, &real_time); //检查第二个队列

		} else {
			if ((total + money) >= 0) {
				total = total + money;
				if (real_time <= time) {
					addtime1(&customer, time, real_time);
					real_time = time + average_time;
				} else {
					addtime2(&customer, time, real_time);
					real_time = real_time + average_time;
				}
			} else {
				//DeQueue(queue1);
				EnQueue(queue2, money, time);
				//real_time = time;
			}
		}
	}
	//这个时候第一列已经没人了，最后一次检查第二列，第二列都是取钱的，一旦取不了钱，直接结算等待时间，出队列后不用再入队列
	check_queue_last(queue2, total, past_total, customer, average_time, &real_time);
	if (queue2->front == queue2->rear)
		print_cust(customer);

	else {
		finfish_queue(queue2, close_time, customer);
		print_cust(customer);
	}
}
```
#### 括号配对检验
```c
//括号配对检验

#include <stdio.h>

#include <stdlib.h>

#include <string.h>

  

#define STACKSIZE 100

#define OVERFLOW -1

#define ERROR -1

#define OK 1

  

typedef struct {

    char *base;

    char *top;

    int stacksize;

} SqStack;

  

void InitStack(SqStack *sqstack) {

    sqstack->base = (char *)malloc(STACKSIZE * sizeof(char));

    if (!sqstack->base)

        exit(OVERFLOW);

    sqstack->top = sqstack->base;

    sqstack->stacksize = STACKSIZE;

}

  

char pop(SqStack *sqstack) {

    char e;

    if (sqstack->top == sqstack->base)

        return ERROR;

    e = * sqstack->top;

    sqstack->top--;

    return e;

}

  

void Push(SqStack *sqstack, char e) {

    if (sqstack->top - sqstack->base >= sqstack->stacksize) {

        sqstack->base = (char *)realloc(sqstack->base, (sqstack->stacksize + STACKSIZE) * sizeof(char));

        if (!sqstack->base)

            exit(OVERFLOW);

        sqstack->top = sqstack->base + sqstack->stacksize;

        sqstack->stacksize += STACKSIZE;

    }

    sqstack->top++;

    *sqstack->top = e;

}

  

int main() {

    char buffer[STACKSIZE];

    int i = 0;

    char e = NULL;

    SqStack sqstack;

    InitStack(&sqstack);

    printf("请输入：");

    fgets(buffer, sizeof(buffer), stdin);//閺堚偓婢舵艾锝為崘锟�100娑擄拷

    if (buffer[0] == '\n') {

        printf("未检测到输入");

        free(sqstack.base);

        return ERROR;

  

    } else if (buffer[0] == ']' || buffer[0] == '}' || buffer[0] == ')') {

  

        free(sqstack.base);

        return ERROR;

    }

  

    while (buffer[i] != '\n') {

        if (buffer[i] == '[' || buffer[i] == '{' || buffer[i] == '(') {

            Push(&sqstack, buffer[i]);

            i++;

        } else if (buffer[i] == ']' || buffer[i] == '}' || buffer[i] == ')') {

            e = pop(&sqstack);

            if ((buffer[i] == ']' && e == '[') || (buffer[i] == '}' && e == '{' ) || (buffer[i] == ')' && e == '(')) {

                i++;

            } else {

                free(sqstack.base);

                printf("ERROR");

                return ERROR;

            }

        }

        else i++;

  

    }

    printf("YES");

    free(sqstack.base);

    return 0;

}
```
### 实验三——Huffman树
```c++
#include<bits/stdc++.h>

using namespace std;

//判断指定位是否为0，若index位为0，则GET_BYTE值为假，否则为真

#define GET_BYTE(value, index) (((value) & (1 << ((index) ^ 7))) != 0)

//将指定位，置为1

#define SET_BYTE(value, index) ((value) |= (1 << ((index) ^ 7)))

//将指定位，置为0

#define CLR_BYTE(value, index) ((value) &= (~(1 << ((index) ^ 7))))

typedef unsigned char uchar;

typedef long long ll;

struct HTNode {

    unsigned char data='o'; // 结点的数据

    int parent=-1;

    int lch=-1;

    int rch=-1; // 双亲结点和孩子结点的下标

    ll weight; // 结点的权值

};

HTNode node[512];//数组存储的哈夫曼树

char filename[30];//文件名

char srcfile[30]="test/";//源文件前缀，待压缩文件

char goalfile[30]="compressed/";//目标文件前缀，即huff文件

char srcfile_1[30]="compressed/";//源文件前缀，即.huff文件

char goalfile_1[30]="decompressed/";//目标文件前缀，即解压缩得到的文件

map<uchar,string>map1;

ll tongji[256]={0};//统计字符词频

int n=0;//记录叶子数，即字符数

//优先队列的比较函数

  

ll zg;//源文件的总字符数，用于判断何时终止读取

  

struct cmp{

    bool operator()(const int a,const int b){

        if(node[a].weight!=node[b].weight)return node[a].weight>node[b].weight;

        return a>b;

    }

};

priority_queue<int,vector<int>,cmp>q;//辅助构造哈夫曼树，即快速找到最小项和次小项

//读取源文件

void read_file(){

    cout<<"请输入文件名:";

    scanf("%s",filename);

    strcat(srcfile,filename);

    FILE* pf=fopen(srcfile,"rb");

    if(pf==NULL){

        perror("fopen");

        return;

    }

    //记录词频

    uchar c=fgetc(pf);

    while(!feof(pf)){

        tongji[c]++;

        c=fgetc(pf);

    }

    fclose(pf);

}

  

void HTcst_1(){

    for(int i=0;i<n;i++)q.push(i);

    for(int i=n;i<2*n-1;i++){

        int x=q.top();

        q.pop();

        int y=q.top();

        q.pop();

        node[i].weight=node[x].weight+node[y].weight;

        node[i].lch=x;

        node[i].rch=y;

        node[x].parent=i;

        node[y].parent=i;

        q.push(i);

    }

}

  

//哈夫曼树构造

void HTcst(){

    int cnt=0;

    //将出现的字符及词频(weight)写入数组前面

    for(int i=0;i<256;i++){

        if(tongji[i]){

            node[cnt].data=i;

            node[cnt].weight=tongji[i];

            q.push(cnt);

            cnt++;

        }

    }

    n=cnt;

    //开始构造，即每次选取最小项和次小项

    for(int i=cnt;i<2*cnt-1;i++){

        int x=q.top();

        q.pop();

        int y=q.top();

        q.pop();

        node[i].weight=node[x].weight+node[y].weight;

        node[i].lch=x;

        node[i].rch=y;

        node[x].parent=i;

        node[y].parent=i;

        q.push(i);

    }

}

//输出哈夫曼树，用于调试代码4

void HTopt(){

    for(int i=0;i<2*n-1;i++){

        cout<<i<<' '<<"data:"<<node[i].data<<' '<<"weight:"<<node[i].weight<<"parent:"<<node[i].parent<<'\n';

    }

}

//哈夫曼编码，左子树为0，右子树为1，并保存在map1中

void table(){

    string s="";

    for(int i=0;i<n;i++){

        int tmp=i;

        auto p=node[tmp].parent;

        while(p!=-1){

            if(node[p].lch==tmp){

                s="0"+s;

            }else{

                s="1"+s;

            }

            tmp=p;

            p=node[p].parent;

        }

        map1[node[i].data]=s;

        s="";

    }

}

//输出map1中的值，用于调试代码

void table_opt(){

    for(auto &t: map1){

        cout<<t.first<<' '<<t.second<<'\n';

    }

}

//写入目标文件，即~~~.huff文件

void wf(){

    FILE* pf2=fopen(srcfile,"rb");

    if(pf2==NULL){

        perror("fopen");

        return;

    }

    strcat(filename,".huff");

    strcat(goalfile,filename);

    FILE* pf=fopen(goalfile,"wb");

    if(pf==NULL){

        perror("fopen");

        return;

    }

    //写哈夫曼编码表,其实本质是各字符词频

    fprintf(pf,"%lld\n",node[2*n-2].weight);

    fprintf(pf,"%d\n",n);

    for(int i=0;i<n;i++){

        fprintf(pf,"%c",node[i].data);

        fprintf(pf,"%lld\n",node[i].weight);

    }

    // for(int i=0;i<n;i++){

    //  fprintf(pf,"%c",node[i].data);

    //  char tmp[100]={0};

    //  strcpy(tmp,map1[node[i].data].c_str());

    //  fprintf(pf,"%s\n",tmp);

    // }

    // 写入编码后01串数据

    unsigned char value;

    int index=0;

    uchar c=fgetc(pf2);

    while(!feof(pf2)){

        for(char x : map1[c]){

            if(x == '0'){

                CLR_BYTE(value, index);

            }

            if(x == '1'){

                SET_BYTE(value, index);

            }

            if(++index >= 8){

                index = 0;

                fwrite(&value, 1, 1, pf);

                // fprintf(pf,"%c",value);

            }

        }

        c=fgetc(pf2);

    }

    if(index){

        // fprintf(pf,"%c",value);

        fwrite(&value, 1, 1, pf);

    }

    fclose(pf);

    fclose(pf2);

}

  

void rf(){

    cout<<"请输入文件名:";

    scanf("%s",filename);

    strcat(goalfile_1,filename);

    strcat(filename,".huff");

    strcat(srcfile_1,filename);

    FILE* pf2=fopen(goalfile_1,"wb");

    if(pf2==NULL){

        perror("fopen");

        return;

    }

    FILE* pf=fopen(srcfile_1,"rb");

    if(pf==NULL){

        perror("fopen");

        return;

    }

    //读取总字符数，叶子数，以及各字符的词频

    uchar x;

    ll cnt;

    fscanf(pf,"%lld",&zg);

    fscanf(pf,"%c",&x);

    fscanf(pf,"%d",&n);

    for(int i=0;i<n;i++){

        fscanf(pf,"%c",&x);

        fscanf(pf,"%c",&x);

        fscanf(pf,"%lld",&cnt);

        node[i].weight=cnt;

        node[i].data=x;

    }

    //构造哈夫曼树

    HTcst_1();

    //解码压缩的01串

    fscanf(pf,"%c",&x);//缓冲掉前面的\n符

    int root=n*2-2;//根节点

    ll jilu=0;//记录已经输出了几个字符，用于判断何时停止

    int flag=0;//辅助判断何时停止

    x=fgetc(pf);

    while(!feof(pf)){

        int index=0;

        while(index<8){

            if(GET_BYTE(x, index) == 0){

                root = node[root].lch;

            }

            if(GET_BYTE(x, index) == 1){

                root = node[root].rch;

            }

            if(node[root].rch == -1 && node[root].lch == -1){

                fprintf(pf2,"%c",node[root].data);

                jilu++;

                root = n*2-2;

            }

            if(jilu>=zg){

                flag=1;

                break;

            }

            index++;

        }

        if(flag)break;

        x=fgetc(pf);

    }

    fclose(pf2);

    fclose(pf);

}

  

int main(){

    int tell=0;

    printf("1. 压缩\n2. 解压缩");

    scanf("%d",&tell);

    if(tell==1){

    read_file();

    HTcst();

    table();

    // table_opt();

    wf();}

    else if(tell==2){

        rf();

    }

    return 0;

}
```
---
### 实验四——图
#### 图的遍历(BFS/DFS)
```c
#include <stdio.h>

#include <stdlib.h>

  

#define MAX_VERTEX_NUM 100

  

//队列的定义

typedef struct QueueNode {

    int vertex;

    struct QueueNode *next;

} QueueNode;

  

// 队列

typedef struct Queue {

    QueueNode *front;

    QueueNode *rear;

} Queue;

  

//创建队列

Queue *createQueue() {

    Queue *queue = (Queue *)malloc(sizeof(Queue));

    queue->front = queue->rear = NULL;

    return queue;

}

  

// 队列是否为空

int isQueueEmpty(Queue *queue) {

    return queue->front == NULL;

}

  

// 入队

void enqueue(Queue *queue, int vertex) {

    QueueNode *newNode = (QueueNode *)malloc(sizeof(QueueNode));

    newNode->vertex = vertex;

    newNode->next = NULL;

  

    if (isQueueEmpty(queue)) {

        queue->front = queue->rear = newNode;

        return;

    }

  

    queue->rear->next = newNode;

    queue->rear = newNode;

}

  

// 出队

int dequeue(Queue *queue) {

    if (isQueueEmpty(queue)) {

        return -1;

    }

  

    QueueNode *temp = queue->front;

    int vertex = temp->vertex;

    queue->front = queue->front->next;

  

    if (queue->front == NULL) {

        queue->rear = NULL;

    }

  

    free(temp);

    return vertex;

}

  

//图的定义（邻接表）

typedef struct node { //储存边的结点

    int adjvex;

    struct node *nextarc;

    int *info;

} ArcNode;

  

typedef struct Node { //储存点的结点（表头）

    int data;

    ArcNode *firstarc;

} VNode, AdjList[MAX_VERTEX_NUM];

  

typedef struct {

    AdjList vertices;

    int vexnum, arcnum;

    int kind;

} ALGraph;

  
  

ALGraph *create_graph(int n, int e) {

    int i = 0;

    int temp1 = 0, temp2 = 0;

    ALGraph *graph = (ALGraph *)malloc(sizeof(ALGraph));

    graph->kind = 0; //表明为无向图

    graph->vexnum = n;

    graph->arcnum = e;

    for (i = 0; i < n; i++) {

        graph->vertices[i].firstarc = NULL;

    }

    return graph;

}

  

void addedge(ALGraph *graph, int i, int j) { //添加从i到j的边,小的边在前面

    ArcNode *new_node = (ArcNode *)malloc(sizeof(ArcNode));

    new_node->adjvex = j - 1;

    new_node->nextarc = NULL;

    if (graph->vertices[i - 1].firstarc == NULL) {

        graph->vertices[i - 1].firstarc = new_node;

    } else {

        ArcNode *current = graph->vertices[i - 1].firstarc;

        ArcNode *past = graph->vertices[i - 1].firstarc;

        while (current != NULL && current->adjvex < j - 1) {

            past = current;

            current = current->nextarc;

        }

        if (current == past) {

            graph->vertices[i - 1].firstarc = new_node;

            new_node->nextarc = current;

        } else {

  

            past->nextarc = new_node;

            new_node->nextarc = current;

        }

    }

}

  

void DFS(ALGraph *graph, int first, int visited[]) { //深度遍历

    visited[first - 1] = 1;

    printf("%d ", first);

    ArcNode *current = graph->vertices[first - 1].firstarc;

    for (current = graph->vertices[first - 1].firstarc; current != NULL; current = current->nextarc) {

        if (!visited[current->adjvex]) {

            DFS(graph, current->adjvex + 1, visited);

        }

    }

  

}

  

void BFS(ALGraph *graph, int first, int visited[]) { //广度遍历

    visited[first - 1] = 1;

    ArcNode *current = graph->vertices[first - 1].firstarc;

    Queue *queue = createQueue();

    enqueue(queue, first - 1);

    while (!isQueueEmpty(queue)) {

        int currentVertex = dequeue(queue);

        printf("%d ", currentVertex + 1);

  

        ArcNode *temp = graph->vertices[currentVertex].firstarc;

  

        while (temp) {

            int adjVertex = temp->adjvex;

  

            if (!visited[adjVertex]) {

                visited[adjVertex] = 1;

                enqueue(queue, adjVertex);

            }

  

            temp = temp->nextarc;

        }

    }

}

  

int main() {

    int n = 0, e = 0;

    int i = 0;

    int temp1 = 0, temp2 = 0;

    int choose = 0, first = 0;

    printf("请输入顶点数和边数");

    scanf("%d %d", &n, &e);

    ALGraph *graph = create_graph(n, e);

    for (i = 0; i < e; i++) {

        scanf("%d %d", &temp1, &temp2);

        addedge(graph, temp1, temp2);

        addedge(graph, temp2, temp1);

    }

    int visited[n];

    for (i = 0; i < n; i++) { //全部标记为未访问

        visited[i] = 0;

    }

    printf("DFS 1\nBFS 2\n");

    scanf("%d", &choose);

    printf("选择起始结点");

    scanf("%d", &first);

    if (choose == 1) {

        DFS(graph, first, visited);

    } else if (choose == 2) {

        BFS(graph, first, visited);

    }

    return 0;

}
```

#### 网的最小代价生成树
```c
#include <stdio.h>

#include <stdlib.h>

  

#define MAX_VERTEX_NUM 100

  

//图的定义（邻接表）

typedef struct node { //储存边的结点

    int adjvex;

    struct node *nextarc;

    int info;

} ArcNode;

  

typedef struct Node { //储存点的结点（表头）

    int data;

    ArcNode *firstarc;

} VNode, AdjList[MAX_VERTEX_NUM];

  

typedef struct {

    AdjList vertices;

    int vexnum, arcnum;

    int kind;

} ALGraph;

  

ALGraph *create_graph(int n, int e) {

    int i = 0;

    int temp1 = 0, temp2 = 0;

    ALGraph *graph = (ALGraph *)malloc(sizeof(ALGraph));

    graph->kind = 0; //表明为无向图

    graph->vexnum = n;

    graph->arcnum = e;

    for (i = 0; i < n; i++) {

        graph->vertices[i].firstarc = NULL;

    }

    return graph;

}

  

void addedge(ALGraph *graph, int i, int j, int num) { //添加从i到j的边,小的边在前面

    ArcNode *new_node = (ArcNode *)malloc(sizeof(ArcNode));

    new_node->adjvex = j - 1;

    new_node->info = num;

    new_node->nextarc = NULL;

    if (graph->vertices[i - 1].firstarc == NULL) {

        graph->vertices[i - 1].firstarc = new_node;

    } else {

        ArcNode *current = graph->vertices[i - 1].firstarc;

        ArcNode *past = graph->vertices[i - 1].firstarc;

        while (current != NULL && current->adjvex < j - 1) {

            past = current;

            current = current->nextarc;

        }

        if (current == past) {

            graph->vertices[i - 1].firstarc = new_node;

            new_node->nextarc = current;

        } else {

  

            past->nextarc = new_node;

            new_node->nextarc = current;

        }

    }

}

  

void deledge(ALGraph *graph, int i, int j) { //删除i,j间结点

    ArcNode *current = graph->vertices[i - 1].firstarc;

    ArcNode *past = graph->vertices[i - 1].firstarc;

    while (current->adjvex != j - 1) {

        past = current;

        current = current->nextarc;

    }

    if (current == past) {

        graph->vertices[i - 1].firstarc = current->nextarc;

        free(current);

    } else {

        past->nextarc = current->nextarc;

        free(current);

    }

}

  

//Kruskal

typedef struct edge { //用来存放边的权重以及比大小

    int head;

    int dest;

    int num;

    int visited;

    Edge *next;

} Edge;

  

Edge *EnEdge(Edge *edge, int head, int dest, int num) { //将权重为num的边按照从小到大插入链表中

    Edge *temp = (Edge *)malloc(sizeof(Edge));

    temp->head = head;

    temp->dest = dest;

    temp->num = num;

    temp->next = NULL;

    temp->visited = 0;

    if (edge == NULL) {

        edge = temp;

    } else {

        Edge *current = edge;

        Edge *past = edge;

        while (current != NULL && current->num < num) {

            past = current;

            current = current->next;

        }

        if (current == past) {

            edge = temp;

            temp->next = current;

        } else {

            past->next = temp;

            temp->next = current;

        }

    }

    return edge;

}

  

int DFS(ALGraph *graph, int first, int visited[]) { //深度遍历,用于检验是否有回路

    int bool_1 = 0;

    visited[first - 1] = 1;

    ArcNode *current = graph->vertices[first - 1].firstarc;

    for (current = graph->vertices[first - 1].firstarc; current != NULL; current = current->nextarc) {

        if (!visited[current->adjvex]) {

            DFS(graph, (current->adjvex) + 1, visited);

        } else

            bool_1 = 1; //表示形成了回路

    }

    return bool_1;

}

  

void Kruskal(Edge *edge, int n, int e, int visited[]) {

    int total = 0;

    Edge *current = edge;

    ALGraph *graph = create_graph(n, e); //创建一个新图

    addedge(graph, current->head, current->dest, current->num);

    current = current->next;

    while (current != NULL) {

        addedge(graph, current->head, current->dest, current->num);

        addedge(graph, current->dest, current->head, current->num);

        for (int i = 0; i < n; i++)

            visited[i] = 0;

        if (DFS(graph, current->head, visited)) { //如果形成了图，则将该路删去

            current->visited = 1;

            deledge(graph, current->head, current->dest);

            deledge(graph, current->dest, current->head);

        }

        current = current->next;

    }

    current = edge;

    while (current != NULL) {

        if (current->visited != 1)

            total = total + current->num;

        current = current->next;

    }

    printf("%d", total);

}

  

//Prim

typedef struct close {

    int num;

    int dest;//表明该条线的另一个顶点和谁相连

} Close;

  

void Prim(ALGraph *graph, Close close[]) {

    int total = 0; //储存权值

    int n = graph->vexnum;

    int min = 1000; //设置一个很大的数，方便比较

    int min_adj = 0; //用来储存最小边的结点

    for (int i = 0; i < n; i++) {

        close[i].num = -1; //数组初始化

    }

    close[0].num = 0; //将第一个点加入到生成树中

    ArcNode *current = graph->vertices[0].firstarc;

    while (current != NULL) { //更新close的边的数据

        if (close[current->adjvex].num < 0) {

            close[current->adjvex].num = current->info;

            close[current->adjvex].dest = current->adjvex;

        } else if (current->info < close[current->adjvex].num) {

            close[current->adjvex].num = current->info;

            close[current->adjvex].dest = current->adjvex;

        }

        current = current->nextarc;

    }

    for (int j = 1; j < n; j++) {

        for (int i = 0; i < n; i++) { //找出最小的数

            if (min >= close[i].num && close[i].num > 0) {

                min = close[i].num;

                min_adj = close[i].dest;

            }

        }

        total = total + min;

        close[min_adj].num = 0; //将该点加入生成树中

  

        current = graph->vertices[min_adj].firstarc;

  

        while (current != NULL) { //更新close的边的数据

            if (close[current->adjvex].num < 0) {

                close[current->adjvex].num = current->info;

                close[current->adjvex].dest = current->adjvex;

            } else if (current->info < close[current->adjvex].num && close[current->adjvex].num > 0) {

                close[current->adjvex].num = current->info;

                close[current->adjvex].dest = current->adjvex;

            }

            current = current->nextarc;

        }

        min = 1000; //将min重新设置

    }

    printf("%d", total);

}

  
  

int main() {

    int n = 0, e = 0, num = 0;

    int i = 0;

    int temp1 = 0, temp2 = 0;

    int choose = 0, first = 0;

    int visited[n];

    Close close[n];

  

    printf("请输入顶点数和边数");

    scanf("%d %d", &n, &e);

    for (int i = 0; i < n; i++)

        visited[i] = 0;

    ALGraph *graph = create_graph(n, e);

    Edge *edge = NULL;

    for (i = 0; i < e; i++) {

        scanf("%d %d %d", &temp1, &temp2, &num);

        addedge(graph, temp1, temp2, num);

        addedge(graph, temp2, temp1, num);

        edge = EnEdge(edge, temp1, temp2, num);

    }

    printf("Kruskal 1\nPrim 2\n");

    scanf("%d", &choose);

    if (choose == 1) {

        Kruskal(edge, n, e, visited);

    } else if (choose == 2) {

  

        Prim(graph, close);//prim输入助教给的输入时有问题，还得改

    }

    return 0;

}
```

#### 铁路交通网最短路径——Dijkstra
```c
#include <stdio.h>

#include <stdlib.h>

  

#define MAX_VERTEX_NUM 100

  

//图的定义（邻接表）

typedef struct node { //储存边的结点

    int adjvex;

    struct node *nextarc;

    int info;

} ArcNode;

  

typedef struct Node { //储存点的结点（表头）

    int data;

    ArcNode *firstarc;

} VNode, AdjList[MAX_VERTEX_NUM];

  

typedef struct {

    AdjList vertices;

    int vexnum, arcnum;

    int kind;

} ALGraph;

  

typedef struct {

    int num;

    int visited;

} Route;

  

ALGraph *create_graph(int n, int e) {

    int i = 0;

    int temp1 = 0, temp2 = 0;

    ALGraph *graph = (ALGraph *)malloc(sizeof(ALGraph));

    graph->kind = 0; //表明为无向图

    graph->vexnum = n;

    graph->arcnum = e;

    for (i = 0; i < n; i++) {

        graph->vertices[i].firstarc = NULL;

    }

    return graph;

}

  

void addedge(ALGraph *graph, int i, int j, int num) { //添加从i到j的边,小的边在前面

    ArcNode *new_node = (ArcNode *)malloc(sizeof(ArcNode));

    new_node->adjvex = j - 1;

    new_node->info = num;

    new_node->nextarc = NULL;

    if (graph->vertices[i - 1].firstarc == NULL) {

        graph->vertices[i - 1].firstarc = new_node;

    } else {

        ArcNode *current = graph->vertices[i - 1].firstarc;

        ArcNode *past = graph->vertices[i - 1].firstarc;

        while (current != NULL && current->adjvex < j - 1) {

            past = current;

            current = current->nextarc;

        }

        if (current == past) {

            graph->vertices[i - 1].firstarc = new_node;

            new_node->nextarc = current;

        } else {

  

            past->nextarc = new_node;

            new_node->nextarc = current;

        }

    }

}

  

void deledge(ALGraph *graph, int i, int j) { //删除i,j间结点

    ArcNode *current = graph->vertices[i - 1].firstarc;

    ArcNode *past = graph->vertices[i - 1].firstarc;

    while (current->adjvex != j - 1) {

        past = current;

        current = current->nextarc;

    }

    if (current == past) {

        graph->vertices[i - 1].firstarc = current->nextarc;

        free(current);

    } else {

        past->nextarc = current->nextarc;

        free(current);

    }

}

  

void Dijkstra(ALGraph *graph, int begin, int end, Route route[]) {

    int n = graph->vexnum;

    int min = 1000, min_num = 0;

    for (int i = 0; i < n; i++) {

        route[i].num = -1; //没有无穷大，用负数代替好了

        route[i].visited = 0; //初始均为未访问

    }

    ArcNode *current = graph->vertices[begin - 1].firstarc;

    route[begin - 1].num = 0; //表示到自身最短路径为0

    route[begin - 1].visited = 1;

    while (current != NULL) {

        route[current->adjvex].num = current->info; //第一次更新

        current = current->nextarc;

    }

    for (int j = 1; j < n; j++) {

        for (int i = 0; i < n; i++) { //寻找最小的路径

            if (route[i].visited == 0 && route[i].num < min && route[i].num != -1) {

                min = route[i].num;

                min_num = i;

            }

        }

        current = graph->vertices[min_num].firstarc;

        while (current != NULL) {

            if (route[current->adjvex].visited == 0) {

                if (route[current->adjvex].num == -1)

                    route[current->adjvex].num = current->info + route[min_num].num;

                else if ((route[min_num].num + current->info) < route[current->adjvex].num)

                    route[current->adjvex].num = route[min_num].num + current->info;

            }

            current = current->nextarc;

        }

        route[min_num].visited = 1;

        min = 1000;

    }

    printf("%d", route[end - 1].num);

}

  

int main() {

    int n = 0, e = 0;

    int i = 0;

    int temp1 = 0, temp2 = 0, num = 0;

    int begin = 0, end = 0;

    printf("请输入顶点数和边数");

    scanf("%d %d", &n, &e);

    ALGraph *graph = create_graph(n, e);

    for (i = 0; i < e; i++) {

        scanf("%d %d %d", &temp1, &temp2, &num);

        addedge(graph, temp1, temp2, num);

        addedge(graph, temp2, temp1, num);

    }

    int visited[n];

    for (i = 0; i < n; i++) { //全部标记为未访问

        visited[i] = 0;

    }

    Route route[n];

    printf("起点和终点\n");

    scanf("%d %d", &begin, &end);

    Dijkstra(graph, begin, end, route);

    return 0;

}
```
### 实验五——Hash表
> 1. 除余留数法构建Hash函数
> 2. 线性探测法解决冲突
> 3. 拉链法解决冲突
> 4. 计算2、3两种方法下查找成功/失败的平均查找长度（ASL）
> 5. 查找给定关键字，给出比较次数
```c
//hash表
#include <stdio.h>
#include <stdlib.h>

#define TABLE_SIZE 11
#define ERROR -1

int search_bool;//表示查找成功or失败

typedef struct hash { //线性探测法的hash表
	int *elem;//储存基址
	int count;//储存的值的个数
	int length;//hash表长度
} Hash;

typedef struct HashNode { //hashtable的结点
	int data;
	struct HashNode *next;
} HashNode;

typedef struct HashTable { //拉链法的hash表
	HashNode **table;
	int size;
} HashTable;

int Function_hash(int x, int p) { //除留余数法
	int result = 0;
	result = x % p;
	return result;
}

Hash *create_hash(int length) { //创建hash表
	Hash *hash = (Hash *)malloc(sizeof(Hash));
	hash->length = length;
	hash->count = 0;
	hash->elem = (int *)malloc(length * sizeof(int));
	for (int i = 0; i < length; i++) {
		hash->elem[i] = -1; //初始化
	}
	return hash;
}

void insert_hash(int key, int p, Hash *hash) { //将x插入hash
	int result = Function_hash(key, p);
	if (hash->elem[result] == -1) {
		hash->elem[result] = key;
	} else {
		result = (result + 1) % hash->length;
		while (hash->elem[result] != -1)
			result = (result + 1) % hash->length;
		hash->elem[result] = key;
	}
}

int search_hash(int key, int p, Hash *hash) { //在hash中查找key,返回查找次数
	int freq = 0; //查找次数
	int f_key = Function_hash(key, p);
	int temp = hash->elem[f_key];
	while (hash->elem[f_key] != -1 && hash->elem[f_key] != key) {
		f_key = f_key + 1;
		freq = freq + 1;
	}
	freq = freq + 1;
	if (hash->elem[f_key] == -1)
		search_bool = 0; //查找失败
	else if (hash->elem[f_key] == key)
		search_bool = 1; //查找成功
	return freq;
}

float ASL_true_hash(Hash *hash, int p, int num[], int n) { //hash表成功查找的平均长度
	float total = 0;
	int temp = 0;
	for (int i = 0; i < n; i++) {
		temp = search_hash(num[i], p, hash);
		if (search_bool)
			total = total + temp;
	}
	total = total / n;
	return total;
}

float ASL_false_hash(Hash *hash) { //hash表失败查找的平均长度
	float total = 0;
	int temp = 1; //至少查找一次
	for (int i = 0; i < hash->length; i++) {
		while (hash->elem[(i + temp) % hash->length] != -1 && temp != hash->length) {
			temp = temp + 1;
		}
		total = total + temp;
		temp = 1;
	}
	total = total / hash->length;
	return total;
}

void initHashTable(HashTable *table, int size) { //hashtable初始化
	table->size = size;
	table->table = (HashNode **)malloc(size * sizeof(HashNode *));
	for (int i = 0; i < size; i++) {
		table->table[i] = NULL; // 初始化所有桶为NULL
	}
}

HashNode *createNode(int data) {//hashtable创建结点
	HashNode *newNode = (HashNode *)malloc(sizeof(HashNode));
	if (!newNode) {
		return NULL; // 内存分配失败
	}
	newNode->data = data;
	newNode->next = NULL;
	return newNode;
}

void insertHashTable(HashTable *table, int data, int p) { //插入hashtable表
	unsigned int index = Function_hash(data, p);
	HashNode *newNode = createNode(data);
	HashNode *current = table->table[index];
	if (current == NULL)
		table->table[index] = newNode;
	else {
		while (current->next != NULL) {
			current = current->next;
		}
		// 将新节点插入到链表尾部
		current->next = newNode;
		newNode->next = NULL;
	}
}

int search_hashtable(int key, int p, HashTable *hashtable) { //hashtable中查找key，返回查找次数
	int freq = 0; //查找次数
	int f_key = Function_hash(key, p);
	HashNode *current = hashtable->table[f_key];
	if (hashtable->table[f_key] == NULL)
		return freq;
	else {
		while (current != NULL && current->data != key) {
			current = current->next;
			freq = freq + 1;
		}
		freq = freq + 1;
		if (current->data == key)
			return freq;
		else
			return ERROR;
	}
}

float ASL_true_hashtable(HashTable *hashtable, int p, int num[], int n) {
	float total = 0;
	int temp = 0;
	for (int i = 0; i < n; i++) {
		temp = search_hashtable(num[i], p, hashtable);
		if (temp != -1)
			total = total + temp;
	}
	total = total / n;
	return total;
}

float ASL_false_hashtable(HashTable *hashtable) { //hash表失败查找的平均长度
	float total = 0;
	int temp = 1;
	HashNode *current = hashtable->table[0];
	for (int i = 0; i < hashtable->size; i++) {
		current = hashtable->table[i];
		while (current != NULL) {
			temp = temp + 1;
			current = current->next;
		}
		total = total + temp;
		temp = 1;
	}
	total = total / hashtable->size;
	return total;
}


int main() {
	int n = 0, p = 0;
	float result = 0;
	int choose = 0;
	int i = 0, temp = 0;
	printf("请输入n:");
	scanf("%d", &n);
	int num[n];
	int *rigth = (int *)malloc(TABLE_SIZE * sizeof(int));
	int *false_1 = (int *)malloc(TABLE_SIZE * sizeof(int));
	for (i = 0; i < TABLE_SIZE; i++) {
		rigth[i] = 0;
		false_1[i] = 0;
	}
	for (int i = 0; i < n; i++) {
		scanf("%d", &num[i]);
		getchar();
	}
	printf("请输入p");
	scanf("%d", &p);
	printf("1. 线性探测法解决冲突\n2. 拉链法解决冲突");
	scanf("%d", &choose);
	if (choose == 1) {
		Hash *hash = create_hash(TABLE_SIZE);
		for (i = 0; i < n; i++) {
			insert_hash(num[i], p, hash);
		}
		printf("哈希表的地址：      ");
		for (i = 0; i < TABLE_SIZE; i++) {
			printf("%d ", i);
		}
		printf("\n表中的关键字：      ");
		for (i = 0; i < TABLE_SIZE; i++) {
			if (hash->elem[i] == -1)
				printf("- ");
			else
				printf("%d ", hash->elem[i]);
		}
		printf("\n成功查找次数：      ");
		for (i = 0; i < TABLE_SIZE; i++) {
			temp = search_hash(hash->elem[i], p, hash);
			if (search_bool == 1)
				rigth[i] = temp;
			else
				rigth[i] = 0;
		}
		for (i = 0; i < TABLE_SIZE; i++) {
			printf("%d ", rigth[i]);
		}
		printf("\n失败查找次数：      ");
		temp = 0; //重置temp值
		for (i = 0; i < hash->length; i++) {
			while (hash->elem[(i + temp) % hash->length] != -1 && temp != hash->length) {
				temp = temp + 1;
			}
			temp = temp + 1;
			//false_1[i] = temp;
			printf("%d ", temp);
			temp = 0;

		}
		result = ASL_true_hash(hash, p, num, n);
		printf("\n查找成功的平均查找长度：%f", result);
		result = ASL_false_hash(hash);
		printf("\n查找失败的平均查找长度：%f", result);
	} else {
		HashTable *hashtable = (HashTable *)malloc(sizeof(HashTable));
		initHashTable(hashtable, TABLE_SIZE);
		for (i = 0; i < n; i++) {
			insertHashTable(hashtable, num[i], p);
		}
		HashNode *current = hashtable->table[0];
		HashNode *current_1 = hashtable->table[0];
		printf("地址  关键字  成功查找次数  失败查找次数\n");
		for (i = 0; i < TABLE_SIZE; i++) {
			printf("%d ", i);
			current = hashtable->table[i];
			if (hashtable->table[i] == NULL)
				printf("-   0   1");//打印关键字
			else {
				while (current != NULL) {
					printf("%d   ", current->data);
					temp = search_hashtable(current->data, p, hashtable); //成功查找次数
					if (temp != -1)
						printf("%d   ", temp);
					temp = 1;
					current_1 = hashtable->table[i]; //失败查找次数
					while (current_1 != NULL) {
						temp = temp + 1;
						current_1 = current_1->next;
					}
					printf("%d ", temp);
					current = current->next;
					if (current != NULL)
						printf("\n  ");
				}
			}
			printf("\n");
		}
		result = ASL_true_hashtable(hashtable, p, num, n);
		printf("查找成功的平均查找长度：%f", result);
		result = ASL_false_hashtable(hashtable);
		printf("\n查找失败的平均查找长度：%f", result);
	}
	return 0;
}
```
