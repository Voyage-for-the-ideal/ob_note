### 第一次实验——稀疏一元多项式计算
#### 功能实现
创建多项式（按升序排列）；输出多项式（升序排列）；多项式求和/求差；求值；销毁；清空；修改（插入新节点；修改结点系数/指数）；微分/积分/不定积分


### 第二次实验——栈
#### 括号配对检验
> 判断每个括号是否匹配
1. malloc的使用
2. base/top型的栈的初始化是**初始化其中的base指针**（给他分配内存）
3. elemtype *  与elemtype的区别。一个使用->,一个使用.
4. 在if中如果使用了多重逻辑，一定要检查括号
#### 银行业务模拟
> 见实验说明
1. 队列从尾(rear)进，从头（front）出
2. 在给结构体初始化之前，需要先用malloc为其分配空间，否则传入函数的结构体无法被修改（未分配空间时，其得到的内存地址是随机的）
3. 在一开始写的时候，将money定义成char变量了，很抽象。之后可以试试审查每个函数的输入变量
5. 链表和队列的区别，队列会额外定义一个结构体储存头、尾结点；而链表可直接为若干个结点（不需要额外定义结构体）
6. 关于传入customer，但是函数外的customer无法改变的问题
	只有传入这个变量的地址才可以改变，换句话说，如果要改变一个指针，那么需要传入这个指针的地址，即，指针的指针。如果仅仅传入指针本身的话，那么这个指针在函数内的改变不会影响主函数的内容；如果传入指针的地址，那么函数所生成的指针地址指向的内容就是主函数中的指针。
7. 还要判断第一个是不是取钱的，因为这个时候不需要检查队列（或者说，就算检查了，也可以直接退出）
8. 其实并不用每次有一个操作完成就对剩下的等待时间相加，只需抓住：“wait=开始检查时间-到来的时间”即可。
9. 注意：
	1. 如果没有进行借钱/还钱步骤，那么不需要消耗时间（到的太晚的不需要考虑）
	2. 任何时候都只开一个窗口
10. 步骤
	1. 队列定义：客户等待时间；客户交易是否完成（判断等待时间是否需要增加）；客户交易数目；客户到银行的时间；客户序号
	3. 确定总客户数，客户交易时间，营业时间和初始金额
	4. 确定每个客户的借/还钱以及到达银行的时间
		2. 输入保证客户按照升序时间来银行
	5. 将所有客户从队列尾输入第一个队列，以及将所有客户存入原始链表
	6. 从队列头逐个输出各个客户
		1. 1~N号客户存钱->全部存进去，修改银行的钱，增加客户等待时间
		2. 客户存钱
				1. 修改客户完成状态；将这之后的每个客户的等待时间增加（不包括这个客户），增加实际时间；修改银行的钱，记录银行修改之前的钱M；将这个客户出队首
				2. 检查第二个队列能不能给客户钱（记得用for循环标注有没有检查到队尾）
					2. 可以，修改客户状态；修改第二个队列客户等待时间，实际时间；修改银行的钱
						比较这个时候银行的钱和M的大小：
						M大->继续；M小->终止检查
					3. 不可以，将客户从队首出列又存入队尾
		1. 客户取钱
			1. 足够
				1. 修改客户完成状态；将这之后的每个客户的等待时间增加（不包括这个客户），增加实际时间；修改银行的钱，记录银行修改之前的钱M；将这个客户出队首
			2. 不够->出一队队首，入二队队尾
	6. 第一队没人了->检查第二队（参照上文检查的流程（去掉M的比较））
		1. 可以给钱->修改一条龙
		2. 不能给->出队首入队尾
	7. 检查完一遍->计算下班还有多久->给剩下的每个人增加时间->计算平均时间->按照一开始的顺序输出客户等待时间

### 第三次实验（huff树）
> 根据字符集构建huffman树，进一步生成huffman编码。将文件按字符进行压缩（huffman编码）。打包封装文件/识别文件进行解码
#### 需要的函数
1. 读文件
	1. 是否需要根据文件类型决定不同的编码方式？
	2. 考虑将文件后缀省略读取文件名，修改为xxx.huff
	   用strrchr得到无后缀的文件名
	   用strcat将.huff加到无后缀文件名后
1. 写文件
	1. **如何储存字典（存放每个字符的huffman编码方式）？**
	   在.huff文件开头空出char[256]，存放每个字符对应的huffman编码；再在开头搞一个unsigned int，计算总文件大小（解压时用于if循环）；再来一个char，存放文件类型
	2. 如何将文件中的字符转换成huffman编码？
	   设置一个char[]缓存区，
1. 由字符出现频率生成huffman树
2. 由huffman树构造huffman编码（字典）
	1. 从根开始寻找每个结点
3. 压缩
	1. 由huffman编码处理原文件
	2. 生成压缩文件
4. 解压
	1. 识别后缀为.huff的文件
	   使用**strrchr**函数判断
	2. 由huffman编码处理压缩文件
	   读取int整型->得到文件大小；
	   读取char[256]，存放huffman编码；
	   读取char，得到文件类型。
	3. 生成解压文件
#### 关于huffman编码需要的工具
> n为字符种类数
1. 一个Huffman树：2n-1个空间的数组，用以存放编码方式
2. 一个int数组：用以储存每个字符的出现频率，数组个数为n
3. 一个HuffmanCode：用以存放每个字符的编码方式（比如存A为01）
### 第四次实验（图相关）
#### 图的遍历
> 创建图；显示图；BFS/DFS
1. 需要注意数组是从0开始数的，而打印和输入的时候都是从1开始数的
2. new为c语言中已经预设的变量，不可以自己定义
#### 求网的最小代价生成树
##### Prim
将顶点分为两类，一类在生成树中，一类不在。每次选取连接两类点的边中权值最小的边，将该边和对应的点加入到生成树中，重复操作直到所有点都进入生成树中。
> 在找到了min之后，应当将min重新置为大数，用于下一轮查找
#### Kruskal
每次挑选最小的路径，加入到图中，从该路径的某一端点开始DFS，如果全程都无重复访问的结点，则认为加入后不构成回路，重复该添加操作。

> 在c语言中，**函数的**变量申明统一放在最前面，不然变量申明会被误以为是一个表达式
#### 铁路交通网的最短路径（Dijkstra算法）

### 第五次实验——hash表

#### 除留余数法构建
这个很简单，不谈
#### 线性探测解决冲突
如果冲突，就让地址+1，直到不冲突为止（默认没有存放key的位置为-1）
#### 拉链法解决冲突
如果冲突，构造一个结点，添加到末尾（为了配合输出的时候显示结构，故添加到末尾而非表头）
在写结构体的时候，因为指向数组(指针)的指针卡了一下，这里需要用双重指针来定义，如果直接写数组定义的话，则无法动态分配数组大小
#### 计算平均查找长度
注意result应当被定义为float类型变量，因此函数需要返回float类型，printf需要用%f。
**查找失败长度**：查找一个hash表中不存在的值，所花费的“解决冲突”的次数。所以，查找失败长度不需要用到原始的关键字数组，只需要对hash表本身遍历即可。
#### 在hash表中查找给定关键字
并不难，会解决冲突就会写这个
### 其他
1. 快慢指针
	1. 实现寻找中间结点（这样只需要遍历一遍链表）
	2. 单链表是否带环（带环则快慢指针相遇）